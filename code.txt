在startserver（）函数中调用SplitAllFilesAndSaveBlocks();


private void SplitAllFilesAndSaveBlocks()
        {
            string currentFolderPath = Path.GetDirectoryName(Application.ExecutablePath);
            string allFilesFolderPath = Path.Combine(currentFolderPath, "../../../all_files");
            string[] allFiles = Directory.GetFiles(allFilesFolderPath);

            foreach (string file in allFiles)
            {
                SplitFileAndSaveBlocks(file);
            }
        }


private void SplitFileAndSaveBlocks(string inputFilePath)
        {
            string blockBaseFolderPath = "../../../block";
            int fixedHashValue = 0;

            // Create a new folder named after the input file
            string fileName = Path.GetFileNameWithoutExtension(inputFilePath);
            string blockFolderPath = Path.Combine(blockBaseFolderPath, fileName);
            Directory.CreateDirectory(blockFolderPath);

            List<byte[]> blocks = SplitFileIntoBlocks(inputFilePath, blockFolderPath, fixedHashValue);

            Console.WriteLine($"File {fileName} has been successfully split into blocks.");
        }



public static List<byte[]> SplitFileIntoBlocks(string filePath, string blockFolderPath, int fixedHashValue)
        {
            byte[] fileContent = File.ReadAllBytes(filePath);
            List<byte[]> blocks = new List<byte[]>();

            int blockStart = 0;
            int blockNumber = 1;
            int windowSize = 3; // Increase the window size to provide a better distribution of hash values

            for (int i = 0; i <= fileContent.Length - windowSize; i++)
            {
                byte[] windowData = new byte[windowSize];
                Array.Copy(fileContent, i, windowData, 0, windowSize);
                int hashValue = CalculateHash(windowData);

                if (hashValue == fixedHashValue)
                {
                    int blockSize = i - blockStart + windowSize;
                    byte[] block = new byte[blockSize];
                    Array.Copy(fileContent, blockStart, block, 0, blockSize);
                    blocks.Add(block);

                    // Save block to file
                    string folderName = Path.GetFileName(blockFolderPath);
                    string blockFileName = $"{folderName}_{blockNumber}.txt";
                    string blockFilePath = Path.Combine(blockFolderPath, blockFileName);
                    File.WriteAllBytes(blockFilePath, block);

                    blockStart = i + windowSize;
                    blockNumber++;
                    i += windowSize - 1; // Move the index to the end of the window
                }
            }

            if (blockStart < fileContent.Length)
            {
                byte[] block = new byte[fileContent.Length - blockStart];
                Array.Copy(fileContent, blockStart, block, 0, block.Length);
                blocks.Add(block);

                // Save block to file
                string folderName = Path.GetFileName(blockFolderPath);
                string blockFileName = $"{folderName}_{blockNumber}.txt";
                string blockFilePath = Path.Combine(blockFolderPath, blockFileName);
                File.WriteAllBytes(blockFilePath, block);
            }

            return blocks;
        }




private static int CalculateHash(byte[] data)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] hashBytes = sha256.ComputeHash(data);
                int hash = BitConverter.ToInt32(hashBytes, 0);
                return Math.Abs(hash) % 2048;
            }
        }


        private string Calculate(byte[] data)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] hashBytes = sha256.ComputeHash(data);
                string hashString = BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();

                string currentFolderPath = Path.GetDirectoryName(Application.ExecutablePath);
                string hashFilePath = Path.Combine(currentFolderPath, "../../../hash.txt");

                // If the hash.txt file doesn't exist, create it
                if (!File.Exists(hashFilePath))
                {
                    File.Create(hashFilePath).Dispose();
                }

                // Append the hash value to the file
                using (StreamWriter writer = File.AppendText(hashFilePath))
                {
                    writer.WriteLine(hashString);
                }

                return hashString;
            }
        }




我实施了option1，并且已经在实验室机器上测试过了

如何运行：按照server-cache-cilent的顺序进行启动。
对于option2，我思考了所需要的技术。我将server中本地文件夹中的数据，在启动server时进行了分块。使用了滚动罗宾算法，将窗口设置为3bytes大小，然后循环遍历